package com.walmart.glitch.demo;

//import com.walmart.glitch.demo.myapi.UserApiDelegate;
//import com.walmart.glitch.demo.mymodel.User;
/*import io.reflectoring.myapi.UserApiDelegate;
import io.reflectoring.mymodel.User;*/
import com.walmart.glitch.demo.myapi.CountryCodeApi;
import com.walmart.glitch.demo.mymodel.LocationResponse;
import io.swagger.annotations.ApiParam;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;

import javax.validation.Valid;
import java.util.Collections;
import java.util.List;

@Service
public class MyApplicationImpl implements CountryCodeApi {

    @Override
    public ResponseEntity<LocationResponse>  getAllLocationsUsingGET(@ApiParam(value = "Standard country code. Example US = USA, CA = Canada",required=true) @PathVariable("countryCode") String countryCode, @ApiParam(value = "Unique name ( application key name) of the producer application as registered in the service registry portal  ( https://reg.soa.walmart.com). Consumer applications have to get a subscription to this producer application in the service registry portal. The actual producer application will have a sidecar deployment of service mesh proxy along with it. Hence all the consumers need to pass the mandatory headers and get authorization and authentication to reach the application.  This header is required in all the environments." ,required=true) @RequestHeader(value="WM_SVC.NAME", required=true) String WM_SVC_NAME, @ApiParam(value = "Name of the environment of the producer application in the service registry portal to which consumer application is subscribed to. For each environment which has to be deployed, an environment is created in service registry portal and same is used to configure the sidecar proxy deployment. As the subscription in service mesh is environment specific; this is a mandatory parameter in all the environments.  Note: Consumers have to pass enviroments according to their subscription. For example if the dev environment of the consumer application is having a subscription to stage environment of the producer application; then only from dev environment of the consumer application stage environment of the producer can be called by passing the WM_SVC.ENV value as stage. " ,required=true) @RequestHeader(value="WM_SVC.ENV", required=true) String WM_SVC_ENV, @ApiParam(value = "Consumer Id in the consumer application from which it has a subscription to the environment (value of WM_SVC.ENV) of the producer application.  Consumer Id can be created in the service registry portal with ssh public key. A unique string will be generated for the given public key.  If a consumer application in dev environment(with consumer Id = 3fa1e5b2-6c55-4d0f-8ae5-634dbbb723242) have a subscription to stage environment of the producer application ( AP-FDS-LOCATIONS-API), then there will be an entry created in the service registry database as AP-FDS-LOCATIONS-API/stage/3fa1e5b2-6c55-4d0f-8ae5-634dbbb723242  Hence when the consumer pass these 3 headers, it will match with the entry in the database; hence the request will be authorized.  This is a mandatory header in all the environments. " ,required=true) @RequestHeader(value="WM_CONSUMER.ID", required=true) String WM_CONSUMER_ID, @ApiParam(value = "Key version of the consumer Id as per the service registry portal. This is autogenerated field when consumer Id is created.  This is a mandatory header in stage & prod environments as the signature authentication is in place." ,required=true) @RequestHeader(value="WM_SEC.KEY_VERSION", required=true) Integer WM_SEC_KEY_VERSION, @ApiParam(value = "Timestamp in epoch at the time of signature generation. As the generated signature expires every 5 mins, timestamp field has to be passed with the signature for the validation.  This is a mandatory field for stage & prod environments as the signature authentication is in place." ,required=true) @RequestHeader(value="WM_CONSUMER.INTIMESTAMP", required=true) Integer WM_CONSUMER_INTIMESTAMP, @ApiParam(value = "Generated signature for authentication. Signature is generated based on private key, consumer Id and the key version.  As the public key is available in service registry portal ( as we have generated consumer Id by submitting ssh public key), generated signature will be decoded by public key and validated using RSA algorithm. Signature will be valid for 5 mins, so that after every 5 mins signature should be regenerated for the new requests.  This is a mandatory header to be passed in stage & prod environments as the signature authetication is in place." ,required=true) @RequestHeader(value="WM_SEC.AUTH_SIGNATURE", required=true) String WM_SEC_AUTH_SIGNATURE, @ApiParam(value = "Comma separated list of fields that will be returned in the response. For example: f=locationNbr,name") @Valid @RequestParam(value = "f", required = false) String f, @ApiParam(value = "Zero based index of number of records to skip from start. If not mentioned, it is considered zero.") @Valid @RequestParam(value = "offset", required = false) Long offset, @ApiParam(value = "Results page you want to retrieve (0..N). If offset is specified, it will be considered too. If not specified, all pages in the result set will be considered.") @Valid @RequestParam(value = "page", required = false) Integer page, @ApiParam(value = "Zero based index of page to fetch. If offset is provided, that too will be considered.") @Valid @RequestParam(value = "pageNumber", required = false) Integer pageNumber, @ApiParam(value = "Specifies number of records per page.") @Valid @RequestParam(value = "pageSize", required = false) Integer pageSize, @ApiParam(value = "Pass 'true' to request paged information.") @Valid @RequestParam(value = "paged", required = false) Boolean paged, @ApiParam(value = "Specifies total/max number of records to fetch.") @Valid @RequestParam(value = "size", required = false) Integer size, @ApiParam(value = "Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.") @Valid @RequestParam(value = "sort", required = false) List<String> sort, @ApiParam(value = "If passed 'true', the sorting criteria mentioned in parameter 'sort' is applied.") @Valid @RequestParam(value = "sort.sorted", required = false) Boolean sortSorted, @ApiParam(value = "") @Valid @RequestParam(value = "sort.unsorted", required = false) Boolean sortUnsorted, @ApiParam(value = "") @Valid @RequestParam(value = "unpaged", required = false) Boolean unpaged) {

        LocationResponse locationResponse = new LocationResponse();
        locationResponse.setSuccess(true);
        //locationResponse.setTimestamp();
        locationResponse.setData(Collections.emptyList());
        return ResponseEntity.ok(locationResponse);
    }

//    @Override
//    public ResponseEntity<User> getUserByName(String username) {
//        User user = new User();
//
//        user.setId(123L);
//        user.setFirstName("Petros");
//        user.setLastName("S");
//        user.setUsername("Petros");
//        user.setEmail("petors.stergioulas94@gmail.com");
//        user.setPassword("secret");
//        user.setPhone("+123 4567890");
//        user.setUserStatus(0);
//
//        return ResponseEntity.ok(user);
//    }


   /* @Override
    public ResponseEntity<SuccessResponse> getReceivingsInfo1(String countryCode,
                                                              Integer vendorNumber,
                                                              Integer purchaseOrderId,
                                                              String lineFlag) {
        User user = new User();

        user.setId(123L);
        user.setFirstName("Petros");
        user.setLastName("S");
        user.setUsername("Petros");
        user.setEmail("petors.stergioulas94@gmail.com");
        user.setPassword("secret");
        user.setPhone("+123 4567890");
        user.setUserStatus(0);

        SuccessResponse successResponse = new SuccessResponse();
        successResponse.setData(Collections.singletonList(user));

        return ResponseEntity.ok(successResponse);
    }*/
}

